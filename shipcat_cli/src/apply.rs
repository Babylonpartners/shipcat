use std::path::{Path};
use std::fs::{self, File};
use std::io::{Write};
use crate::kube;
use shipcat_definitions::structs::Metadata;
use crate::helm;
use crate::webhooks::{self, UpgradeState};

use super::{Manifest, Config, Region, Result, ResultExt, ErrorKind};

/// Information from an upgrade
///
/// This information is generated by apply on a best-effort basis.
/// It is provided for webhooks and notifications to make good interfaces.
/// TODO: remove fork in helm module
#[derive(Clone)]
pub struct UpgradeInfo {
    /// Name of service
    pub name: String,
    /// Metadata for service
    pub metadata: Metadata,
    /// Validated version string
    pub version: String,
    /// Chart the service is using
    chart: String,
    /// Validated region requested for installation
    pub region: String,
    /// Validated namespace inferred from region
    pub namespace: String,
    /// Computed diff string (if available)
    pub diff: Option<String>,
}

impl UpgradeInfo {
    /// Export the information needed for book-keeping
    ///
    /// Requires a valid manifest with a pre-determined version
    pub fn new(mf: &Manifest) ->  Self {
        UpgradeInfo {
            name: mf.name.clone(),
            version: mf.version.clone().expect("version must be set before calling UpgradeInfo::new"),
            metadata: mf.metadata.clone().expect("metadata must exist on every manifest"),
            chart: mf.chart.clone().expect("must have a chart for a manifest"),
            region: mf.region.clone(),
            namespace: mf.namespace.clone(),
            diff: None,
        }
    }
}

/// shipcat apply
///
/// This is the main entrypoint for cli upgrades of a service in a region.
/// It currently uses tiller, but this function will be updated to bypass that soon.
///
/// The design goals of this is to support:
/// - shipcat apply mysvc
/// - shipcat apply mysvc -t semver
/// In both non-rolling environments (preprod/prod), and rolling envs (complement).
///
/// To allow version-less apply in rolling environment, we have to verify with kube
/// what the current version is.
///
/// The preparatory sanity
///
/// This is entry point should be used by both the cli to apply, and reconcile.
/// It is also entirely responsible for sending webhooks on errors / successes.
/// As such, it's entirely responsible for not propagating random errors here with `?`
/// Every error cases is something that might need to be notified.
pub fn apply(mfbase: Manifest,
             force: bool,
             region: &Region,
             conf: &Config,
             wait: bool,
             passed_version: Option<String>) -> Result<Option<UpgradeInfo>>
{
    if let Err(e) = webhooks::ensure_requirements(&region) {
        warn!("Could not ensure webhook requirements: {}", e);
    }
    let svc = mfbase.name.clone();
    // Internal sanity
    assert_eq!(mfbase.region, region.name);
    assert_eq!(mfbase.namespace, region.namespace);

    // A version is set EITHER via `-t SOMEVER` on CLI, or pinned in manifest
    if passed_version.is_some() && mfbase.version.is_some() {
        error!("Overriding a pinned version will be undone at next reconcile");
        bail!("Cannot override version for '{}' because it is pinned in manifests", svc);
    }
    let explicit_version = mfbase.version.clone().or(passed_version);

    // Figure out if the service is already installed
    // This is currently needed to determine whether or not we run a diff.
    // (kube 1.13 diff can work this out, but helm diff can't.)
    // TODO: when on 1.13 only do this when explicit_version.is_none()
    let (exists, fallback) = match kube::get_running_version(&svc, &mfbase.namespace) {
        Ok(running_ver) => (true, running_ver),
        Err(e) => {
            if let Some(v) = &explicit_version {
                warn!("'{}' {} will be installed", svc, v);
                (false, v.to_string())
            } else {
                warn!("'{}' cannot be installed (no version inferable)", svc);
                // can't notify here, it's super spammy to do so because it's:
                // - user upgrading manually without -t on new svc (via CI / cli)
                // - reconcile not knowing what to do for new svc (via CI)
                // These cases are user errors and should be visible therein.
                //
                // The legit cases where we are missing versions in non-rolling
                // environments must be caught elsewhere.
                return Err(e.chain_err(|| ErrorKind::MissingRollingVersion(svc.into())));
            }
        },
    };

    // Determine what version we should actually use
    let actual_version = explicit_version.unwrap_or(fallback);
    debug!("using {}={}", svc, actual_version);
    // Verify it's a legal version (no-shoehorning in illegal versions in rolling envs)
    region.versioningScheme.verify(&actual_version)?;

    let mfcrd = mfbase.version(actual_version);
    let mut ui = UpgradeInfo::new(&mfcrd);

    // Make one complete manifest variant with version and secrets (needs to pass)
    let mf = mfcrd.clone().complete(&region).map_err(|e| {
        // Fire failed events if secrets fail to resolve
        webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
        e
    })?;

    // Move the only incomplete manifest (with version) into kcrd apply
    // Old style apply shipcatmanifest crd (TODO: use kube api for .status setting)
    assert!(mfcrd.version.is_some()); // ensure crd is in right state w/o secrets
    assert!(mfcrd.is_base()); // TODO: inside crd apply fn
    let changed = kube::apply_crd(&svc, mfcrd, &region.namespace)?;
    if exists && !changed && !force {
        info!("{} up to date (crd check)", svc);
        return Ok(None)
    }

    // Create values file
    let hfile = format!("{}.helm.gen.yml", svc);
    values_helm(&mf, &hfile)?;

    // Attach diff to UpgradeInfo if the service exists and we can diff
    if exists { // attach diff if possible
        match diff_helm(&mf, &hfile) {
            Ok(hdiff) => ui.diff = hdiff,
            Err(e) => warn!("Unable to diff against {}: {}", svc, e),
        }
        // If we received no diff, don't try to upgrade
        // This is a stronger diff than CRD-only if this succeeds; STOP.
        if ui.diff.is_none() {
            info!("{} up to date (full diff check)", svc);
            return Ok(None)
        }
    }

    webhooks::apply_event(UpgradeState::Pending, &ui, &region, &conf);
    match upgrade_helm(&mf, &hfile) {
        Err(e) => {
            // upgrade failed immediately - couldn't create resources
            // typically validation failures or rbac faults
            error!("{} from {}", e, ui.name);
            // TODO: write shipcatmanifest .status here...
            webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
            return Err(e);
        },
        Ok(_) => {
            if !wait {
                info!("successfully applied {} (without waiting)", ui.name);
            }
            else {
                match kube::await_rollout_status(&mf) {
                    Ok(success) => {
                        if success {
                            info!("successfully rolled out {}", &ui.name);
                            // TODO: write shipcatmanifest .status here...
                            webhooks::apply_event(UpgradeState::Completed, &ui, &region, &conf);
                        } else {
                            let _ = kube::debug_rollout_status(&mf);
                            let _ = kube::debug(&mf);
                            // TODO: collect these for shipcatmanifest .status
                            warn!("failed to roll out {}", &ui.name);
                            // TODO: write shipcatmanifest .status here...
                            webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
                            return Err(ErrorKind::UpgradeTimeout(mf.name.clone(), mf.estimate_wait_time()).into());
                        }
                    },
                    Err(e) => {
                        webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
                        return Err(e)
                    }
                }
            }
        }
    };
    // cleanups in non-error cases
    let _ = fs::remove_file(&hfile); // try to remove temporary file
    Ok(Some(ui))
}

/// Shell out to helm upgrade
fn upgrade_helm(mf: &Manifest, hfile: &str) -> Result<()> {
    // upgrade it using the same command
    let upgradevec = vec![
        format!("--tiller-namespace={}", mf.namespace),
        "upgrade".into(),
        mf.name.clone(),
        format!("charts/{}", mf.chart.as_ref().unwrap()), // ensured in manifest
        "-f".into(),
        hfile.into(),
        "--set".into(),
        format!("version={}", mf.version.as_ref().unwrap()), // ensured in apply
        "--install".into(),
    ];
    info!("helm {}", upgradevec.join(" "));
    helm::helpers::hexec(upgradevec).chain_err(||
        ErrorKind::HelmUpgradeFailure(mf.name.clone()))?;
    Ok(())
}

/// Minified version of helm::direct::diff
///
/// To be gradually replaced by kubectl diff
pub fn diff_helm(mf: &Manifest, hfile: &str) -> Result<Option<String>> {
    let namespace = mf.namespace.clone();
    let diffvec = vec![
        format!("--tiller-namespace={}", namespace),
        "diff".into(),
        "upgrade".into(),
        "--no-color".into(),
        "-q".into(),
        mf.name.clone(),
        format!("charts/{}", mf.chart.clone().unwrap()),
        "-f".into(),
        hfile.into(),
    ];
    info!("helm {}", diffvec.join(" "));
    let (hdiffunobfusc, hdifferr, _) = helm::helpers::hout(diffvec.clone())?;
    let helmdiff = helm::helpers::obfuscate_secrets(
        hdiffunobfusc, // move this away quickly..
        mf.get_secrets()
    );
    if !hdifferr.is_empty() {
        if hdifferr.starts_with(&format!("Error: \"{}\" has no deployed releases", mf.name)) {
            let cmd = format!("helm --tiller-namespace={} del --purge {}", namespace, mf.name);
            let reason = "to let you be able to retry the install/reconcile";
            error!("Previous installs of {} failed, you need to run: \n\t{}\n{}",
                mf.name, cmd, reason
            );
            // NB: this is coerced into a fake diff rather than an error
            // just because it was super frequent, this part goes away with tiller..
            return Ok(Some(format!("no deployed releases of {} - needs purge", mf.name)));
        }
        warn!("diff {} stderr: \n{}", mf.name, hdifferr);
        if ! hdifferr.contains("error copying from local connection to remote stream") &&
           ! hdifferr.contains("error copying from remote stream to local connection") {
            bail!("diff plugin for {} returned: {}", mf.name, hdifferr.lines().next().unwrap());
        }
    }

    let smalldiff = helm::helpers::diff_format(helmdiff.clone());

    Ok(if !smalldiff.is_empty() {
        debug!("{}", helmdiff); // full diff for logs
        println!("{}", smalldiff);
        Some(smalldiff)
    } else {
        None
    })
}

pub fn values_helm(mf: &Manifest, output: &str) -> Result<()> {
    let encoded = serde_yaml::to_string(&mf)?;
    let pth = Path::new(".").join(output);
    debug!("Writing helm values for {} to {}", mf.name, pth.display());
    let mut f = File::create(&pth)?;
    writeln!(f, "{}", encoded)?;
    debug!("Wrote helm values for {} to {}: \n{}", mf.name, pth.display(), encoded);
    Ok(())
}

/*
a future crd applier, that will probably need changing and updating for kube 1.15
we need to know if things changed ideally..
and presumably the new apply verb will be able to detect that..

it also requires us to not have a separate serialize/deserialize per crate

TODO: define status object

/// Kube interface
type ManifestApi = Api<Object<Manifest, Void>>;

/// Apply a CRD using the kube api
///
/// This uses patch with server side apply. Requires kubernetes 1.15.
fn apply_crd(mf: Manifest, api: ManifestApi) -> Result<bool> {
    let crd = json!({
        apiVersion: "babylontech.co.uk/v1"
        kind: "ShipcatManifest",
        metadata: {
            name: mf.name,
            namepace: mf.namespace,
        }
        spec: mf,
    });
    let pp = PatchParams {
        patch_strategy: PatchStrategy::Apply, // server side apply
        field_manager: Some("shipcat".into()),
        force: true,
        ..Default::default()
    };
    api.patch(mf.name, &pp, serde_json::to_vec(&crd))?;
    Ok(changed)
}

/// Update the status of a crd
fn patch_crd() { unimplemented!() }

*/
