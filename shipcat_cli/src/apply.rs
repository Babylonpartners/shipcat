use std::fs;

use shipcat_definitions::{
    Manifest, Config, Region,
    ReconciliationMode,
    structs::Metadata,
};
use crate::{
    helm,
    kubectl,
    status,
    diff,
    webhooks::{self, UpgradeState}
};

use super::{Result, ResultExt, ErrorKind};

/// Information from an upgrade
///
/// This information is generated by apply on a best-effort basis.
/// It is provided for webhooks and notifications to make good interfaces.
/// TODO: remove fork in helm module
#[derive(Clone)]
pub struct UpgradeInfo {
    /// Name of service
    pub name: String,
    /// Metadata for service
    pub metadata: Metadata,
    /// Validated version string
    pub version: String,
    /// Chart the service is using
    chart: String,
    /// Validated region requested for installation
    pub region: String,
    /// Validated namespace inferred from region
    pub namespace: String,
    /// Computed diff string (if available)
    pub diff: Option<String>,
}

impl UpgradeInfo {
    /// Export the information needed for book-keeping
    ///
    /// Requires a valid manifest with a pre-determined version
    pub fn new(mf: &Manifest) ->  Self {
        UpgradeInfo {
            name: mf.name.clone(),
            version: mf.version.clone().expect("version must be set before calling UpgradeInfo::new"),
            metadata: mf.metadata.clone().expect("metadata must exist on every manifest"),
            chart: mf.chart.clone().expect("must have a chart for a manifest"),
            region: mf.region.clone(),
            namespace: mf.namespace.clone(),
            diff: None,
        }
    }
}

/// shipcat apply
///
/// This is the main entrypoint for cli upgrades of a service in a region.
/// It currently uses tiller, but this function will be updated to bypass that soon.
///
/// The design goals of this is to support:
/// - shipcat apply mysvc
/// - shipcat apply mysvc -t semver
/// In both non-rolling environments (preprod/prod), and rolling envs (complement).
///
/// To allow version-less apply in rolling environment, we have to verify with kube
/// what the current version is.
///
/// The preparatory sanity
///
/// This is entry point should be used by both the cli to apply, and reconcile.
/// It is also entirely responsible for sending webhooks on errors / successes.
/// As such, it's entirely responsible for not propagating random errors here with `?`
/// Every error cases is something that might need to be notified.
pub fn apply(svc: &str,
             force: bool,
             region: &Region,
             conf: &Config,
             wait: bool,
             passed_version: Option<String>) -> Result<Option<UpgradeInfo>>
{
    match region.reconciliationMode {
        ReconciliationMode::CrdStatus =>
            apply_with_crd(svc, force, region, conf, wait, passed_version),
        ReconciliationMode::CrdVersioned =>
            apply_helm(svc, force, region, conf, wait, passed_version),
        _ => unimplemented!()
    }
}


/// Legacy version
///
/// Reads CRDs, but doesn't write to them. Upgrades through tiller.
#[deprecated(since = "0.122.2", note = "CrdVersioned users should move on to CrdStatus")]
fn apply_helm(svc: &str,
             force: bool,
             region: &Region,
             conf: &Config,
             wait: bool,
             passed_version: Option<String>) -> Result<Option<UpgradeInfo>>
{
    warn!("CrdVersioned shipcat::apply is deprecated, please move to CrdStatus");
    if let Err(e) = webhooks::ensure_requirements(&region) {
        warn!("Could not ensure webhook requirements: {}", e);
    }
    let mfbase = shipcat_filebacked::load_manifest(&svc, &conf, &region)?;

    // A version is set EITHER via `-t SOMEVER` on CLI, or pinned in manifest
    if passed_version.is_some() && mfbase.version.is_some() {
        error!("Overriding a pinned version will be undone at next reconcile");
        bail!("Cannot override version for '{}' because it is pinned in manifests", svc);
    }
    let explicit_version = mfbase.version.clone().or(passed_version);

    // Figure out if the service is already installed
    // This is currently needed to determine whether or not we run a diff.
    // (kube 1.13 diff can work this out, but helm diff can't.)
    // TODO: when on 1.13 only do this when explicit_version.is_none()
    let (exists, fallback) = match kubectl::get_running_version(&svc, &mfbase.namespace) {
        Ok(running_ver) => (true, running_ver),
        Err(e) => {
            if let Some(v) = &explicit_version {
                warn!("'{}' {} will be installed", svc, v);
                (false, v.to_string())
            } else {
                warn!("'{}' cannot be installed (no version inferable)", svc);
                // can't notify here, it's super spammy to do so because it's:
                // - user upgrading manually without -t on new svc (via CI / cli)
                // - reconcile not knowing what to do for new svc (via CI)
                // These cases are user errors and should be visible therein.
                //
                // The legit cases where we are missing versions in non-rolling
                // environments must be caught elsewhere.
                return Err(e.chain_err(|| ErrorKind::MissingRollingVersion(svc.into())));
            }
        },
    };

    // Determine what version we should actually use
    let actual_version = explicit_version.unwrap_or(fallback);
    debug!("using {}={}", svc, actual_version);
    // Verify it's a legal version (no-shoehorning in illegal versions in rolling envs)
    region.versioningScheme.verify(&actual_version)?;

    let mfcrd = mfbase.version(actual_version);
    let mut ui = UpgradeInfo::new(&mfcrd);

    // Make one complete manifest variant with version and secrets (needs to pass)
    let mf = mfcrd.clone().complete(&region).map_err(|e| {
        // Fire failed events if secrets fail to resolve
        webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
        e
    })?;

    // Move the only incomplete manifest (with version) into kcrd apply
    // Old style apply shipcatmanifest crd (TODO: use kube api for .status setting)
    assert!(mfcrd.version.is_some()); // ensure crd is in right state w/o secrets
    assert!(mfcrd.is_base()); // TODO: inside crd apply fn
    let changed = kubectl::apply_crd(&svc, mfcrd, &region.namespace)?;
    if exists && !changed && !force {
        info!("{} up to date (crd check)", svc);
        return Ok(None)
    }

    // Create values file
    let hfile = format!("{}.helm.gen.yml", svc);
    helm::values(&mf, &hfile)?;

    // Attach diff to UpgradeInfo if the service exists and we can diff
    if exists { // attach diff if possible
        match diff_helm(&mf, &hfile) {
            Ok(hdiff) => {
                ui.diff = hdiff;
                // If we explicitly received no diff, don't try to upgrade
                // This is a stronger diff than CRD-only if this succeeds; STOP.
                if ui.diff.is_none() {
                    info!("{} up to date (full diff check)", svc);
                    return Ok(None)
                }
            }
            // If diffing failed, only run the upgrade if using --force
            Err(e) => {
                warn!("Unable to diff against {}: {}", svc, e);
                if !force {
                    return Ok(None)
                }
            }
        }
    }

    webhooks::apply_event(UpgradeState::Pending, &ui, &region, &conf);
    match upgrade_helm(&mf, &hfile) {
        Err(e) => {
            // upgrade failed immediately - couldn't create resources
            // typically validation failures or rbac faults
            error!("{} from {}", e, ui.name);
            webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
            return Err(e);
        },
        Ok(_) => {
            if !wait {
                info!("successfully applied {} (without waiting)", ui.name);
            }
            else {
                match kubectl::await_rollout_status(&mf) {
                    Ok(true) => {
                        info!("successfully rolled out {}", &ui.name);
                        webhooks::apply_event(UpgradeState::Completed, &ui, &region, &conf);
                    },
                    Ok(false) => {
                        let _ = kubectl::debug_rollout_status(&mf);
                        let _ = kubectl::debug(&mf);
                        warn!("failed to roll out {}", &ui.name);
                        webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
                        return Err(ErrorKind::UpgradeTimeout(mf.name.clone(), mf.estimate_wait_time()).into());
                    },
                    Err(e) => {
                        webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
                        return Err(e)
                    }
                }
            }
        }
    };
    // cleanups in non-error cases
    let _ = fs::remove_file(&hfile); // try to remove temporary file
    Ok(Some(ui))
}

/// Last version of apply that uses tiller
///
/// This writes events to uses the shipcatmanifest crd
fn apply_with_crd(svc: &str,
             force: bool,
             region: &Region,
             conf: &Config,
             wait: bool,
             passed_version: Option<String>) -> Result<Option<UpgradeInfo>>
{
    if let Err(e) = webhooks::ensure_requirements(&region) {
        warn!("Could not ensure webhook requirements: {}", e);
    }
    let mfbase = shipcat_filebacked::load_manifest(&svc, &conf, &region)?;

    // A version is set EITHER via `-t SOMEVER` on CLI, or pinned in manifest
    if passed_version.is_some() && mfbase.version.is_some() {
        error!("Overriding a pinned version will be undone at next reconcile");
        bail!("Cannot override version for '{}' because it is pinned in manifests", svc);
    }
    let explicit_version = mfbase.version.clone().or(passed_version);

    // Interact with the kube api to get the shipcatmanifest crd and its .status
    // This lets us work out:
    // - if the service has been installed before (negates the need for a diff)
    // - if we need to apply a new crd (so we have an atomic change)
    // - if we need to interact with secret-manager TODO: do
    let s = status::Status::new(&mfbase)?;

    // Next large batch is working out the reason for the upgrade (if any)
    let mut reason = None;
    // Fetch the full shipcatmanifest crd
    // NB: if kube api or early stuff here fails, then we are in a bad state.
    // Before we have applied any CRDs it's safe to bail. Next run can retry.
    let (actual_version, crd) = match s.get() {
        Err(_e) => {
            // This usually fails because it's not yet installed
            // Other error cases: retry later
            match explicit_version {
                None => {
                    warn!("'{}' cannot be installed (no version inferable)", svc);
                    return Err(ErrorKind::MissingRollingVersion(svc.into()).into());
                },
                Some(v) => {
                    reason = Some(UpgradeReason::NewService);
                    (v, None)
                }
            }
        },
        Ok(o) => {
            debug!("existing manifest crd: {}={:?}", o.spec.name, o.status);
            let fallback = o.spec.version.clone().expect("manifest.version set");

            // A version was supplied, and it differs from active CRD
            if explicit_version.is_some() && explicit_version != o.spec.version {
                reason = Some(UpgradeReason::VersionChange);
            }
            (explicit_version.unwrap_or(fallback), Some(o))
         },
    };
    let existed = crd.is_some(); // no crd => nothing installed
    debug!("using {}={}", svc, actual_version);
    // no shoehorning in illegal versions in the crd!
    region.versioningScheme.verify(&actual_version)?;

    // Complete and apply the CRD
    let mfcrd = mfbase.version(actual_version);
    let crd_changed = s.apply(mfcrd.clone())?;
    // Cheap reconcile ends here if !changed && !force
    if crd_changed {
        reason = reason.or(Some(UpgradeReason::ManifestChange));
    }
    if reason.is_none() && !force {
        info!("{} up to date (crd check)", svc);
        return Ok(None)
    }

    // Prepare for an actual upgrade now..
    let mut ui = UpgradeInfo::new(&mfcrd);
    webhooks::apply_event(UpgradeState::Pending, &ui, &region, &conf);

    // Fetch all the secrets so we can create a completed manifest
    // TODO: check scp.status.secretChecksum against secret-manager instead
    let mf = match mfcrd.clone().complete(&region) {
        Err(e) => {
            // Fire failed events if secrets fail to resolve
            webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
            s.update_generate_false("SecretFailure", e.description().to_string())?;
            return Err(e.into());
        },
        Ok(m) => m,
    };

    // Create values file
    let hfile = format!("{}.helm.gen.yml", svc);
    if let Err(e) = helm::values(&mf, &hfile) {
        // Errors here are obscure, and should not happen, but pass them up anyway
        webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
        s.update_generate_false("ResolveFailure", e.description().to_string())?;
        return Err(e);
    };

    // Attach diff to UpgradeInfo if diffing is possible
    // TODO: use kubectl diff in 1.13
    if existed { // helm diff only supports diffing if already installed..
        match diff_helm(&mf, &hfile) {
            Ok(Some(hdiff)) => {
                ui.diff = Some(hdiff);
                reason = reason.or(Some(UpgradeReason::TemplateDiff));
            },
            Ok(None) => {
                // If we explicitly received no diff, don't try to upgrade
                // This is a stronger diff than CRD-only if this succeeds; STOP.
                info!("{} up to date (full diff check)", svc);
                s.update_generate_true()?; // every force reconcile makes one generate cond
                webhooks::apply_event(UpgradeState::Cancelled, &ui, &region, &conf);
                return Ok(None)
            }
            // If diffing failed, only run the upgrade if using --force
            Err(e) => {
                warn!("Unable to diff against {}: {}", svc, e);
                if !force {
                    // pass on a diff failure
                    s.update_generate_false("DiffFailure", e.description().to_string())?;
                    webhooks::apply_event(UpgradeState::Cancelled, &ui, &region, &conf);
                    return Ok(None) // but ultimately ignore this in fast reconciles
                }
                reason = reason.or(Some(UpgradeReason::Forced))
            }
        }
    }

    // We cannot be here without a reason now, although you have to convince yourself.
    let ureason = reason.expect("cannot apply without a reason");
    s.update_generate_true()?; // if this fails, stop, want .status to be correct
    webhooks::apply_event(UpgradeState::Started, &ui, &region, &conf);

    match upgrade_helm(&mf, &hfile) {
        Err(e) => {
            error!("{} from {}", e, ui.name);
            webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
            let reason = e.description().to_string();
            s.update_apply_false(ureason.to_string(), "ApplyFailure", reason)?; // TODO: chain
            return Err(e);
        },
        Ok(_) => {
            let _ = s.update_apply_true(ureason.to_string());
            if !wait {
                info!("successfully applied {} (without waiting)", ui.name);
            }
            else {
                match kubectl::await_rollout_status(&mf) {
                    Ok(true) => {
                        info!("successfully rolled out {}", &ui.name);
                        webhooks::apply_event(UpgradeState::Completed, &ui, &region, &conf);
                        s.update_rollout_true()?;
                    },
                    Ok(false) => {
                        let time = mf.estimate_wait_time();
                        let reason = format!("timed out waiting {}s for rollout", time);
                        let _ = kubectl::debug_rollout_status(&mf);
                        let _ = kubectl::debug(&mf);
                        // TODO: collect these for .status call ^?
                        warn!("failed to roll out {}", &ui.name);
                        webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
                        s.update_rollout_false("Timeout", reason)?; // TODO: chain
                        return Err(ErrorKind::UpgradeTimeout(mf.name.clone(), time).into());
                    },
                    Err(e) => {
                        webhooks::apply_event(UpgradeState::Failed, &ui, &region, &conf);
                        s.update_rollout_false("RolloutTrackFailure", e.description().to_string())?; // TODO: chain
                        return Err(e)
                    }
                }
            }
        }
    };
    // cleanups in non-error cases
    let _ = fs::remove_file(&hfile); // try to remove temporary file
    Ok(Some(ui))
}


/// Reason for an apply being allowed through
///
/// Some of these imply others. We pick the strongest one we can.
#[derive(Debug)]
pub enum UpgradeReason {
    /// New service
    NewService,
    /// New version supplied either in manifest or externally in rolling
    VersionChange,
    /// Configuration change in manifests
    ManifestChange,
    /// Secret updated in vault -> secret manager
    SecretChecksum,
    /// Regional / Chart changes
    TemplateDiff,
    /// Something failed (e.g. diff failed to return) and apply was with --force
    Forced,
}

impl ToString for UpgradeReason {
    fn to_string(&self) -> String {
        format!("{:?}", self)
    }
}


/// Shell out to helm upgrade
fn upgrade_helm(mf: &Manifest, hfile: &str) -> Result<()> {
    // upgrade it using the same command
    let upgradevec = vec![
        format!("--tiller-namespace={}", mf.namespace),
        "upgrade".into(),
        mf.name.clone(),
        format!("charts/{}", mf.chart.as_ref().unwrap()), // ensured in manifest
        "-f".into(),
        hfile.into(),
        "--set".into(),
        format!("version={}", mf.version.as_ref().unwrap()), // ensured in apply
        "--install".into(),
    ];
    info!("helm {}", upgradevec.join(" "));
    helm::hexec(upgradevec).chain_err(||
        ErrorKind::HelmUpgradeFailure(mf.name.clone()))?;
    Ok(())
}

/// Minified helm diff shell out
///
/// To be gradually replaced by kubectl diff
pub fn diff_helm(mf: &Manifest, hfile: &str) -> Result<Option<String>> {
    let namespace = mf.namespace.clone();
    let diffvec = vec![
        format!("--tiller-namespace={}", namespace),
        "diff".into(),
        "upgrade".into(),
        "--no-color".into(),
        "-q".into(),
        mf.name.clone(),
        format!("charts/{}", mf.chart.clone().unwrap()),
        "-f".into(),
        hfile.into(),
    ];
    info!("helm {}", diffvec.join(" "));
    let (hdiffunobfusc, hdifferr, _) = helm::hout(diffvec.clone())?;
    let helmdiff = diff::obfuscate_secrets(
        hdiffunobfusc, // move this away quickly..
        mf.get_secrets()
    );
    if !hdifferr.is_empty() {
        if hdifferr.starts_with(&format!("Error: \"{}\" has no deployed releases", mf.name)) {
            let cmd = format!("helm --tiller-namespace={} del --purge {}", namespace, mf.name);
            let reason = "to let you be able to retry the install/reconcile";
            error!("Previous installs of {} failed, you need to run: \n\t{}\n{}",
                mf.name, cmd, reason
            );
            // NB: this is coerced into a fake diff rather than an error
            // just because it was super frequent, this part goes away with tiller..
            return Ok(Some(format!("no deployed releases of {} - needs purge", mf.name)));
        }
        warn!("diff {} stderr: \n{}", mf.name, hdifferr);
        if ! hdifferr.contains("error copying from local connection to remote stream") &&
           ! hdifferr.contains("error copying from remote stream to local connection") {
            bail!("diff plugin for {} returned: {}", mf.name, hdifferr.lines().next().unwrap());
        }
    }

    let smalldiff = diff::minify(helmdiff.clone());

    Ok(if !smalldiff.is_empty() {
        debug!("{}", helmdiff); // full diff for logs
        println!("{}", smalldiff);
        Some(smalldiff)
    } else {
        None
    })
}
